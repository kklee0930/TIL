리스트 컴프리헨션(List Comprehension)

문자열

1.문자열 슬라이싱

2.문자열 메서드

3.아스키(ASCII) 코드

💻문자열 슬라이싱
문자열은 변경 불가능한 자료형이다.
순회가 가능하다 (iterable) / 변경이 불가능하다 (immutable)

word = 'apple'이라고 하면 apple의 주소를 할당하는 것이다.

s = 'abcdefghi' 에서 s[2:5]를 해도 s가 변한 것은 아니다. 슬라이싱을 해도 원본이 변하지는 않는다.
s[-6:-2] => 'defg'

꿀팁 음의 슬라이싱이 헷갈린다면 문자열의 길이를 슬라이싱 범위에 더해 보자.
len(s) = 9, s[-6+len(s):-2+len(s)] == s[-6:-2] 가 된다!

s[2:5:2] = > ce
s[-6:-1:3] => dg
s[2:5:-1] => '' 왜 공백일까?
s[5:2:-1] => fed

💻문자열 메서드
.split():문자열을 일정 기준으로 나누어서 리스트로 반환
아무것도 넣지 않으면 자동으로 공백을 기준으로 설정

.strip():문자열의 "양쪽 끝"에 있는 특정 문자를 모두 제거한 후에 새로운 문자열을 반환
아무것도 넣지 않으면 자동으로 공백을 제거 문자로 설정

.find():특정 문자가 "처음으로" 나타나는 위치(인덱스)를 반환한다.
찾는 문자가 없다면 -1을 반환한다.

.index():특정 문자가 "처음으로" 나타나는 위치(인덱스)를 반환한다.
찾는 문자가 없다면 "오류"가 발생한다.

그래서 차이점이 무엇일까?
find의 경우 끝까지 실행이 되고 index의 경우 도중에 오류가 발생하여 중단된다.
비슷한 메서드인거 같은데 왜 두개가 존재하는 걸까??: 뭔가 문제가 발생하였을 때 개발자의 입장에서 에러가 발생하는 것이 문제가 무엇인지 확인하고 해결하는데에 도움이 되기 때문에 에러가 발생하는 것이 더욱 좋은 경우도 있다.

.count():문자열에서 특정 문자의 갯수를 반환

.replace(기존문자, 새로운문자):문자열에서 기존 문자를 새로운 문자로 수정한 새로운 문자열을 "반환"한다.
특정 문자를 빈 문자열("")로 수정하여 마치 해당 문자를 삭제한 것 같은 효과를 낼 수도 있다.

삽입할문자.join(iterable):iterable의 각각 우너소 사이에 특정 문자를 삽입한 새로운 문자열을 "반환"한다.
공백 출력, 콤마 출력 등 원하는 출력 형태를 위해 사용이 가능하다.

💻아스키(ASCII) 코드: 가장 보편적으로 쓰이는 문자 체계
ASCII(American Standard Code for Information Interchange): 미국 정보교환 표준부호
모든 알파벳을 숫자로 변환할 수 있다! 알파벳을 표현하는 대표 인코딩 방식
각 문자를 표현하는데 1byte(8bit)를 사용한다.
1bit: 통신에러 저장용
7bit:

ord(문자) => 문자를 아스키 코드로 변환해준다.
ord('A') = 65

chr(코드) -> 아스키 코드를 문자로 변환해준다.
chr(65) = 'A'
