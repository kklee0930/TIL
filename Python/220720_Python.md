### 💻Self:

호출하는 인스턴스를 파이썬 **내부적으로** 그대로 전달해준다.

```python
#self는 인스턴스가 지니는 값을 넘겨주는 역할을 한다.
class Person:
    # self가 자동으로 넘어가기 때문에 name만 입력해주면 되는 것이다.
    def __init__(self, name):
        self.name = name

    def greeting(self):
        print(f'안녕하세요, {self.name}입니다.')

        # 아래는 출력이 안된다. 왜나햐면 인스턴스가 지니는 name 값을 불러올 수 없기 때문에
        print(f'안녕하세요, {name}입니다.')

gildong = Person('길동')
gildong.greeting()
```

로또 번호 자동생성기를 함수화 해보자.

```python
import random

# 5장 사자
for i in range(5):
    number = range(1,46)
    result = random.sample(number)
    result.sort()
    print(result)

# 함수화 해보자.
def lotto(n):
    lotto_list = []
    for i in range(n):
        number = range(1,46)
        result = random.sample(number, 6)
        result.sort()
        lotto_list.append(result)
    print(lotto_list)

# 다른 환경에서 import 해서 사용할 때
import lotto_generator
print('파일명'.lotto_generator(5))
```

로또 번호 자동생성기를 여러 기능을 지니는 클래스로 만들어보자.

```python

내가 한 번 짜보자....!

class Lotto:
    def __init__(self, n):
        lotto_list = []
        for i in range(n):
            number = range(1,46)
            result = random.sample(number, 6)
            result.sort()
            lotto_list.append(result)
        print(lotto_list)

    def check_num(self, real_num):
        if self.
```

💻클래스

클래스 속성(attribute):

LEGB Rule
인스턴스와 클래스 간의 이름 공간(namespace):

인스턴스 메서드

함수가 인스턴스를 호출하면서 인스턴스에 메서드 사용이 필요할 때 사용한다.

클래스 메소드

- 내부적으로 클래스에 메서드 사용이 필요할 때 사용한다.
- 클래스가 사용할 메소드
- 오직 클래스만을 위한 메소드이다. 클래스에만 적용된다.
- @classmethod 데코레이터를 사용하여 정의한다.
  데코레이터: 함수를 어떤 함수로 꾸며서 새로운 기능을 부여
  호출 시, 첫번 째 인자로 클래스(cls)가 전달된다.

스태틱 메소드

- 내부적으로 클래스, 인스턴스 모두 필요가 없을 때 사용한다.
- 인스턴스 변수, 클래스 변수를 전혀 다루지 않는 메소드
- 기능없이 단지 행동만을 할 때 사용되는 메소드?

```python
class MyClass:

    #클래스 차원에서 사용할 수 있는 변수
    class_variable = '클래스변수'

    def __init__(self):
        self.instance_variable = '인스턴스 변수'

    #인스턴스 메서드 정의
    def instance_method(self):
        return self, self.instance_method

    #클래스 메서드 정의
    @classmethod
    def class_method(cls):
        return cls, cls.class_variable

    #스태틱 메서드 정의
    @staticmethod
    def static_method():
        return '스태틱'

c1 = MyClass()
print('인스턴스 변수 호출', c1.instance_variable)
print('인스턴스 메서드 호출', c1.instance_method())
print('클래스 메서드 호출', c1.class_method())
print('스태틱 메서드 호출', c1.static_method())
```

💻객체 지향의 핵심개념

- 객체지향의 핵심 4가지

1. 추상화: 클래스 내에 기능들을 만들어 놓고 인스턴스 생성 시, 기능을 이용할 수 있게 해주는 개념. 이러한 모습을 만들어 놓는 것을 추상화라고 한다. 표현을 하기 위한 하나의 모습

2. 상속: 두 클래스 간의 부모-자식 관게를 정립하는 것이다. 상속을 통해 상위 클래스에 정의된 속성, 행동, 관계 및 제약조건을 모두 하위 클래스에게 전달이 가능하다. 재사용성이 향상된다.
   `isinstance(object, classinfo)`: 실제로 인스턴스인지 확인 가능
   `issubclass(class, classinfo)`: 상속관계인지 알아보는 메서드
   `super()`: 부모클래스의 요소를 호출할 수 있다. 자식클래스에서 부모 클래스를 사용하고 싶은 경우 활용한다. `super().__init__(name, age)`이런식으로 코드를 다시 작성할 필요 없이 새로 추가하고 싶은 값만 추가할 수 있다.

- 메서드 오버라이딩을 통해 자식 클래스에서 재정의가 가능하다.
- 상속관계에서의 이름 공간은 인스턴스, 자식 클래스, 부모 클래스 순으로 탐색한다.

- 다중상속
  두개 이상의 클래스를 상속 받는 경우
  상속 받은 모든 클래스의 요소를 활용이 가능하다.
  중복된 속성이나 메서드가 있는 경우 상속 순서에 의해 결정된다.

3. 다형성: 동일한 메서드가 상속 받는 자식 클래스에 따라 조금 다르게 정의되는 개념이다.

- 메서드 오버라이딩: 메서드 덮어쓰기 기능이다. 메스드를 재정의 하는 것이다.

4. 캡슐화:

파이썬에서는 접근 제어를 지원하지 않는데, 왜냐하면 수단과 방법을 다 쓰면 접근이 가능하다.

- 접근 제어자 종류

1. Public Access Modifier: 어디서나 호출이 가능하다. 하위 클래스 override를 허용한다.
2. Protected Access Modifier: 부모/자식 간에만 호출이 가능하다.
3. Private Access Modifier: 본인만 접근이 가능하다. 클래스 그 자체에서만 가능하다는 뜻이다.
