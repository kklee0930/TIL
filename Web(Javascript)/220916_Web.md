### 💻ECMA Script

#### 변수와 식별자

- 식별자는 변수를 구분할 수 있는 변수명을 뜻함

- 식별자로 예약어 사용이 불가능

- 식별자는 반드시 문자, 달러($), 밑줄(\_)로 시작

#### 🌟변수는 선언, 할당, 초기화를 통해 조작/생성한다.

- 선언(Delcaration): 변수를 생성하는 행위

- 할당(Assignment): 선언된 변수에 값을 저장하는 행위

- 초기화(Initialization): 선언된 변수에 "처음으로" 값을 저장하는 행위

```javascript
// Declaration
const foo
console.log(foo) // undefined

// Assignment
foo = 11
console.log(foo) // 11

// Initialiation
let bar = 12
console.log(bar) // 12
```

<br>

#### let과 const의 차이

둘다 재선언(Declaration)은 불가능하지만

`let`은 재할당이 가능하다.

`const`는 재할당이 불가능하다.

즉 추후 변경 가능성이 있는 변수는 `let`으로 생성하고

변경 가능성이 없는 변수는 `const`로 생성한다.

```javascript
let a = 11;
a = 12;
console.log(a); // 12

const b = 99;
b = 100; // 불가능
```

⛔둘다 재선언은 불가능하다.

```javascript
let a = 100;
let a = 101; // 불가능

const b = 100;
const b = 101; // 불가능
```

<br>

#### var

var로 선언한 변수는 재선언 및 재할당이 모두 가능하다.

그래서 현재 ES에서는 잘 사용되지 않는다.

실수로 재선언시 문제가 발생할 수 있다.

```javascript
var num = 100;
console.log(num); // 100

var num = 200;
console.log(num); // 200
```

⛔var로 선언한 변수는 hoising(호이스팅) 문제를 야기할 수 있다

<br>

#### hoisting

자바스크립트에서는 코드 실행 전에 모든 선언을 스코프에 등록하는 과정을 거친다.

이렇게 변수선언/함수선언이 먼저 저장되어 있기 때문에, 선언문보다 참조/호출이 먼저 나와도 코드가 오류없이 작동된다.

즉 hoisting이란,

> 이 호이스팅이라는 용어를 자바스크립트 실행 컨텍스트에 의한 위에 설명한 현상을 호이스팅이라고 부른다는 것으로 이해하면 되겠다. 그 현상이란 선언이 코드 실행 보다 먼저 메모리에 저장되는 과정으로 인한 현상을 말한다.

출처: [호이스팅이란](https://hanamon.kr/javascript-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%EC%9D%B4%EB%9E%80-hoisting/)

<br>

#### Let vs Const vs Var

![](220916_Web.assets/a.png)

<br>

##### 블록스코프 vs 함수스코프

블록스코프: if, for, 함수 등의 중괄호 내부를 가르킨다.

함수스코프: 함수의 중괄호 내부를 가르킨다.

블록스코프 / 함수스코프를 가지는 변수는 모두 함수 바깥에서 접근이 불가능하다.

```javascript
// 블록스코프
let x = 1;
if (x === 1) {
  let x = 2;
  console.log(x); // 2
}
console.log(x); // 1

// 함수스코프
function foo() {
  var x = 5;
  console.log(x); // 5
}
console.log(x); // ReferenceError: x is not defined
```

<br>

### 💻데이터 타입

원시타입(Primitive type)과 참조타입(Reference type)으로 나뉨

🌟객체이냐 객체가 아니냐로 구분이 가능하다.

![](220916_Web.assets/datatype.png)

<br>

#### Primitive Type(원시타입)

- 객체가 아닌 기본 타입

- 변수에 해당 타입의 값이 담김

- 다른 변수에 복사할 때 실제 값이 복사됨

```javascript
let message = "hello!";

let greeting = message;
console.log(greeting); // hello!

message = "안녕하세요!";
console.log(greeting); // hello!
```

<br>

#### Reference Type(참조타입)

- 객체 타입의 자료형

- 변수에 해당 객체의 참조 값이 담김

- 다른 변수에 복사할 때 참조 값이 복사됨

```javascript
const message = ["hello!"]; // Array

const greeting = message;
console.log(greeting); // ['hello!']

message[0] = "안녕하세요!";
console.log(greeing); // ['안녕하세요!]
```

<br>

#### Number(숫자타입)

- 정수, 실수 구분없음(하나의 숫자타입)

- 부동소수점 형식을 따름

##### 🌟NaN(Not a Number): 계산 불가능한 값이다.

    예: 'Javascript' / 3.14 == NaN

```javascript
const a = 13;
const b = -5;
const c = 3.14;
const d = 2.998e8; // 거듭제곱
const e = Infinity; // 양의 무한대
const f = -Infinity; // 음의 무한대
const g = NaN; // 산술 연산 불가
```

<br>

#### String(문자열타입)

- 텍스트 데이터를 나타냄

- 템플릿 리터럴(Template Literal) 활용

  - 따옴표 대신 백틱(`)을 사용한다.

  - `${expression}` 형태로 표현이 가능하다.

  - 🍯파이썬의 f-string이라고 생각하면 된다.

  ```javascript
  const firstName = "Brandon";
  const lastName = "Eich";
  const fullName = `${firstName} ${lastName}`;

  console.log(fullName); // Brandon Eich
  ```

<br>

#### undefined

- 변수 선언 이후 값을 할당하지 않으면 해당 변수에는 undefined가 할당된다.

- 변수의 값이 없음을 나타냄

```javascript
let foo;
console.log(foo); // undefined
```

<br>

#### null
