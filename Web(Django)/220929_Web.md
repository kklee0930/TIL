### 💻Namespace

- 개체를 구분할 수 있는 범위를 나타내는 것이 namespace(이름 공간)

```python
# pages/urls.py

from django.urls import path
from . import views

urlpatterns = [
    path('index/', views.index, name='index'),
]

# pages/views.py

def index(request):
    return render(request, 'index.html')
```

```html
<!-- pages/templates/index.html -->

{% extends 'base.html' %} {% block %}
<h1>두번 째 앱의 index</h1>
{% endblock %}

<!-- articles/templates/index.html -->

{% extends 'base.html' %} {% block %}
<h1>만나서 반가워요!</h1>
<a href="{% url 'greeting' %}">greeting</a>
<a href="{% url 'dinner' %}">dinner</a>
<a herf="{% url 'throw' %}">throw</a>

<a href="{% url 'index' %}">두번째 앱 index로 이동</a>
{% endblock %}
```

⛔pages에서도 같은 index.html가 존재하기 때문에 articles의 index.html로 이동하는 것이 아닌 pages의 index.html로 이동하는 문제가 발생한다.

#### URL namespace

🌟이를 막기 위해서 URL namespace를 활용하여 서로 다른 앱에서 동일한 URL 이름을 이용하는 경우에도 의도한 URL로 이동하게 한다

- app_name attribute를 작성해 URL namespace를 설정

```python
# articles/urls.py

app_name = 'articles'
urlpatterns = [
    ...,
]

# pages/urls.py

app_name = 'pages'
urlpatterns = [
    ...,
]
```

##### 적용 예시

```html
{% url 'index' %}를 {% url 'articles:index' %}로 변경
```

```html
<!-- articles/templates/index.html -->
{% extends 'base.html' %} {% block content %}
<h1>만나서 반가워요!</h1>
<a href="{% url 'articles:greeting' %}">greeting</a>
<a href="{% url 'articles:dinner'%}">dinner</a>
<a href="{% url 'articles:throw'%}">throw</a>

<a herf="{% url 'pages:index' %}">두번 째 앱 index로 이동</a>
{% endblock content %}
```

### 💻Template namespace

- 단일 앱으로만 이루어진 프로젝트라면 상관없지만,

- 여러 앱으로 이루어졌을 경우 템플릿 파일 이름이 겹치면 문제가 발생할 수 있기에 구분하는 것이 필요함

#### Naming URL patterns

- DTL의 Tag 중 하나인 URL 태그를 사용해서 path() 함수에 작성한 name 사용

- URL에 이름을 지정하여 view 함수와 템플릿에서 특정 주소 쉽게 참조하도록 함

```python
# articles/urls.py

urlpatterns = [
    path('index/', views.index, name='index'),
    path('greeting/', views.greeting, name='greeting'),
    path('dinner/', views.dinner, name='dinner'),
    path('throw/', views.throw, name='throw'),
    path('catch/', views.catch, name='catch'),
    path('hello/<str:name>/', views.hello, name='hello'),
]
```

#### Built-in tag "url"

`{% url '' %}`을 사용하는 방법도 있다.

```html
<!-- catch.html -->

{% extends 'base.html' %} {% block %}
<h1>Catch</h1>
<h2>여기서 {{ message }}를 받는다.</h2>
<a href="{% url 'throw' %}">다시 던지러 돌아감</a>
{% endblock content %}

<!-- throw.html -->

{% extends 'base.html' %} {% block %}
<h1>Throw</h1>
<form action="{% url 'catch' %}" method="GET">...</form>
<a href="{% url 'index' %}">뒤로 돌아가기</a>
{% endblock %}

<!-- index.html -->

{% extends 'base.html' %} {% block %} ...
<a href="{% url 'greeting' %}">greeting</a>
<a href="{% url 'dinner' %}">dinner</a>
<a href="{% url 'throw' %}">throw</a>
{% endblock %}

<!-- dinner.html, greeting.html -->

<a href="{% url 'index' %}">뒤로 돌아가기</a>
```

🍯개발자 도구를 통해 경로 반환 확인이 가능하다

### 💻Django 활용 시

#### Django 설계 철학(Templates System)

1. 표현과 로직(view)을 분리

- 템플릿 시스템은 표현을 제어하는 도구이자 표현에 관련된 로직일 뿐이다

2. 중복 배제

### 💻Django의 구조(MTV Design Pattern)

- MVC 디자인 패턴을 기반으로 변형됨

#### MVC 소프트웨어 디자인 패턴

- Model, View, Controller: 데이터 및 논리 제어를 구현하는데 널리 사용되는 소프트웨어 디자인 패턴

- Model: 데이터와 관련된 로직 관리

- View: 레이아웃과 화면 처리

- Controller: 명령을 model과 view 부분으로 연결

🌟각 부분을 독립적으로 개발이 가능하여 유지보수가 쉽다는 장점이 있다

![](220929_Web.assets/mtv.png)

### 💻Django Model

#### Database

- 체계화된 데이터의 모임

- 검색 및 구조화를 용이하게 하기 위해 조직화된 데이터를 수집하는 저장 시스템

1. Schema

![](220929_Web.assets/schema.png)

- DB에서 자료의 구조, 표현 방법, 관계 등을 정의

2. Table

![](220929_Web.assets/table.png)

- 필드(속성, 컬럼)와 레코드(튜플, 행)를 사용해 조직된 데이터 요소들의 집합

- 관계(Relation)이라고도 부름

##### 🌟Query(쿼리)

- 데이터를 조회하기 위한 명령어

- 조건에 맞는 데이터 추출이나 조작할 때 사용됨(주로 테이블형 자료구조에서)

- "DB를 조작한다" == "쿼리를 날린다"

#### Model

![](220929_Web.assets/model.png)

- Django는 Model을 통해 데이터에 접근하고 조작

- 사용하는 데이터들의 필수적인 필드들과 동작을 포함

- 각각의 모델은 하나의 DB 테이블에 매핑(모델 클래스 1개 == DB 테이블 1개)

##### Model 작성

1. 새 프로젝트(crud), 앱(articles) 작성 및 앱 등록

```bash
$ django-admin startproject [project_name] .
$ python manage.py startapp [app_name]
```

```python
# settings.py

INSTALLED_APPS = [
    'articles',
]
```

2. models.py 작성

- 모델 클래스를 작성하는 것은 DB 테이블의 스키마 정의와 같다

```python
# articles([app_name])/models.py

class Article(models.Model): # django.db.models 모듈의 Model 클래스 상속
    # title과 content는 DB필드를 나타냄
    title = models.CharField(max_length=10)
    content = models.TextField()
```

##### Django Model Field

- 모델필드를 통해 테이블의 필드(컬럼)에 저장할 데이터 유형(INT, TEXT 등) 정의

- 데이터 유형에 따라 다양한 모델 필드 제공(DataField(), CharField() 등)

[Model Field References](https://docs.djangoproject.com/en/3.2/ref/models/fields/)

1. `CharField(max_length=None, **options)`

- 길이의 제한이 있는 문자열 넣을 때 사용

2. `TextField(**options)`

- 글자의 수가 많을 때 사용

🌟아래와 같이 작성한 models.py는 이러한 DB 스키마를 정의한 것이다

```python
# articles([app_name])/models.py

class Article(models.Model): # django.db.models 모듈의 Model 클래스 상속
    # title과 content는 DB필드를 나타냄
    title = models.CharField(max_length=10)
    content = models.TextField()
```

![](220929_Web.assets/modelpy.png)

### 💻Migrations

1. makemigrations

`$ python manage.py makemigrations`

- 모델의 변경사항에 대한 새로운 migration을 만들 때 사용

2. migrate

- makemigrations으로 만든 설계도를 실제 DB에 반영하는 과정(db.sqlite3 파일에 반영)

- 결과적으로 모델의 변경사항과 DB를 동기화

`$ python manage.py migrate`

![](220929_Web.assets/migrate.png)

### 💻Model 변경사항 반영
